\hypertarget{index_intro_sec}{}\section{Introduction}\label{index_intro_sec}
This module of DSM2 is a transport code modeling \hyperlink{a00052}{advection}, \hyperlink{a00056}{diffusion}, sediment processes and reactions.\hypertarget{index_order}{}\section{Recommended Work Plan}\label{index_order}
\begin{enumerate}
\item Get doxygen working. The documentation is automatically built by the MS Visual Studio solution as long as doxygen is on path. See below on \hyperlink{index_viz}{Visual Studio}.\item Code a function-test pair and add it to test\_\-transport\_\-driver(). I suggest you either\begin{itemize}
\item adjust your \hyperlink{a00056}{diffusion} code stylistically and write a matching unit test (see below on unit tests) or\item complete the extrapolate() function in the advect module and write a test for that. See below for how to write good unit tests.\end{itemize}
\item Move the advection.replace\_\-boundary\_\-flux() subroutine out of the \hyperlink{a00052}{advection} model since it it is driver/application specific. This step will teach you about interfaces and callbacks. Discuss the design with Nicky and Kevin and Eli.\item After that, start looking at which functions in the \hyperlink{a00052}{advection} module are not really implemented. Work in function-test pairs (they often evolve together). As much as you can, put \char`\"{}asserts\char`\"{} in your testing function that are needed regardless of whether you can pass them. The \hyperlink{index_tests}{Tests}, and in some ways the documentation, are our way of communicating expected behavior\item You will be at the same point you are in Matlab when you code the uniform flow \hyperlink{a00052}{advection} test. However, we will not want you to code this or turn it in until the other testing (extrapolate(), conservative update) are well tested.\item Do not significantly change the granularity or form of these functions without a design meeting. It is recommended that you discuss the API (names and arguments) of routines and the basic flow as a skeleton before you code along with the tests. If you pass the tests and have a functional form we can use, you have succeeded at the task by definition. In the meantime:\item I recommend you work in this order, but you may rearrange the \hyperlink{a00056}{diffusion} part as you wish:\begin{itemize}
\item code and test existing skeleton routines in the transport library\item code test for uniform flow \hyperlink{a00052}{advection} no source or \hyperlink{a00056}{diffusion}\begin{itemize}
\item achieve comfort with convergence testing\end{itemize}
\item code test for non-uniform flow \hyperlink{a00052}{advection} (handle flow/area consistency issues)\item add linear source and test convergence\item code test for \hyperlink{a00056}{diffusion}\begin{itemize}
\item explicit operator\item implicit solver\begin{itemize}
\item convergence test\end{itemize}
\end{itemize}
\item code test for advective-diffusion\item meet on channel network challenges\item modify for sediment\item complete channel network stuff\end{itemize}
\end{enumerate}
\hypertarget{index_viz}{}\section{Visual Studio}\label{index_viz}
Hopefully we will just give you a complete project that has most of the settings right. To get this to compile you need to make sure you have:\begin{enumerate}
\item Doxygen installed and on path. To get the doc project to generate, you need to have doxygen installed. Make sure it is on path (test by typing doxygen at the command line). You can add to the path on your computer or set it up in Visual Studio's Tools $>$ Options $>$ Projects and Solutions $>$ VC++ Di drectories (for executables) Note the doc project has a custom build step (cd's to /doc and does documentation.bat) output for the custom build step is /doc/html/index.html You can view /doc/html/index.html in Visual Studio by right clicking it and choosing \char`\"{}View in Browser\char`\"{}\item Set up the dependencies (hopefully we will do this for you)\begin{itemize}
\item test\_\-transport on transport and fruit\item sandbox\_\-application on transport (you can alter as desired)e\end{itemize}
\item Set the fortran \char`\"{}additional include directories\char`\"{} in sandbox\_\-application and \hyperlink{a00095}{test\_\-transport\_\-driver} to pick up the fruit and transport module files. Hopefully we will do this for you.\item The sandbox is like scratch paper -- it is an executable project to do whatever you want.\end{enumerate}
\hypertarget{index_driver}{}\section{Module Divisions: Library versus Application}\label{index_driver}
You will notice that the main computational code is in a static library called /transport. In the future we may have other static library modules called /sediment /nonconservative and to deal with I/O.

By and large, the drivers (test code and application) know about the libraries and not vice versa. The drivers do the setup and request the transport library to solve individual time steps. There are a couple nuanced points about this:\begin{itemize}
\item The \hyperlink{a00070}{state\_\-variables} module properly allocates and houses state variables. It is like a utility for drivers tests and applications. You should use the \hyperlink{a00070}{state\_\-variables} module and then pass the variables into the solver as arguments.\item The \hyperlink{a00052_9ec45d9c2fabe0abb0a60795bc228f59}{advection.advect()} function takes a callback for a source term that must be provided by the driver/application. The reason I did this is that we want to be able to stipulate different source terms for different tests. We will probably want to implement advection.replace\_\-boundary\_\-flux() the same way.\item When you use callbacks, you should do so at the level of the whole grid. In other words compute\_\-source is perfectly efficient as long as its job is to compute source over the grid, not a point.\item Other common jobs done by the driver do not affect the interior of advect(). For instance, the initial condition, and hydro\_\-data(). These have to be user supplied. I have tried to include interface blocks for these routines in the library, but not an implementation.\end{itemize}
\hypertarget{index_faces}{}\section{Why All The \_\-lo and \_\-hi Data Structures??? Isn't this Wasteful?}\label{index_faces}
You may notice that I have included a lot of data structures that look like flux\_\-lo(icell) and flux\_\-hi(icell) and in some cases (but not all) you may feel that there is a redundancy because it seems like flux\_\-hi(icell) == flux\_\-hi(icell+1). This, in fact will be true for some data structures for some data. However, when we get to channel networks it will not be true. At that point we will be stuck with a choice between:\begin{itemize}
\item face-centered arrays whose mappings are non-obvious, ie: flux(hi\_\-face(ncell)).\item flux\_\-hi(ncell), which is still perfectly well-defined still.\end{itemize}
\hypertarget{index_tests}{}\section{Tests}\label{index_tests}
I put the Fruit testing framework here directly as a static library to reduce complexity of the project files. We can move it later.

The test\_\-transport project is the first battery of tests. The tests in test\_\-gradient.f90 are fairly complete for that module. You will find a test driver called test\_\-transport\_\-driver.f90 The driver program there is where you would add new tests. Try to have one for every medium sized routine. For algorithms, the best integration tests are either accuracy compared to a known solution or (better) convergence.

Remember, unit tests are silent. They should also be complete and catch \char`\"{}corner\char`\"{} cases. Look at the flux limiter test. I spot checked one \char`\"{}ordinary\char`\"{} case in the middle of the array in a gentle area where the limited flux is just the centered difference. More importantly, I tested both ends of the array and I looked at reversals of sign in both directions and places where the limiter is in use due to big jumps on the hi and lo side.

This is usually a sobering experience.\hypertarget{index_todo}{}\section{Todo Tags}\label{index_todo}
In the code you should use !todo: for any notes to yourself about things to do later. You will already see a few in there. Do not use any other format for this job.\hypertarget{index_style}{}\section{Style Notes:}\label{index_style}
Please try to adhere to these guidelines as well as trying to get a sense of the code already provided and matching its style. Although we encourage you to \char`\"{}not worry about it\char`\"{} when you turn in code every other week, it would be nice if you took 1-2 hours to go over this as a checklist.\begin{itemize}
\item Try to follow the subroutine style. The \hyperlink{a00061}{gradient} module is probably the best example for routines and \hyperlink{a00070}{state\_\-variables} module shows how to encapsulate variables and document them.\item All routines are implicit none. Write this out, do not use compiler options.\item Do not pass data to subroutines by \char`\"{}use\char`\"{} statements. Put data in the signature. Imagine that you want to test the routine later out of context. Long signatures are fine.\item Routine names are lower\_\-underscore. Try to name them with one well chosen word or two, avoiding redundancy. Do not abbreviate unless:\begin{itemize}
\item the abbreviation is very easy to interpret and the original is taxing. For instance, conc is fine for concentration.\item the abbreviation is standard English, in which case you should always use it: e.g. abbr for abbreviation.\item the abbreviation is well established in the code. For instance I use lo and hi to show that a quantity is on face on the lo (n-1) or hi (n+1) side of the cell.\end{itemize}
\item Variables are also lower\_\-underscore.\item Some constants associated with precision like LARGEREAL and STM\_\-REAL are all caps.\begin{itemize}
\item OK, this is a bit consistent but the typesafe scalar values for numbers (one, two, half, etc) in the \hyperlink{a00071}{stm\_\-precision} module are lower because... well it just looks way better\end{itemize}
\item Use the typesafe scalar values for numbers that have them: x = two$\ast$y. This avoids having to keep track of the \char`\"{}d\char`\"{} for double precision and prevents real-double conversion.\item Prefer subroutines to functions.\item Argument lists should not be long. Use continutation lines (\&) when there is more than one line full. See the examples.\item Section off the arguments to all routines. See gradient.f90 for examples\item Section off routines from one another using //////. See gradient.f90\item Declare the intent for every variable.\item Use real(STM\_\-REAL) for floating point. Avoid hardwiring.\item Do not add things like \char`\"{}last modified\char`\"{} that have to be maintained by hand. Let version control do this.\item Put the licence at the top.\item Initialize variables to LARGEREAL or put LARGEREAL in indexes that won't get touched. For instance, if the derivative and value arrays are the same side and you do a \char`\"{}lo-side\char`\"{} difference, there is nothing to put in the first index. Set that to LARGEREAL. The reason for this is that if it gets initialized to something reasonable (the compiler often choses zero, at least in debug mode) it can lead to bugs that look deceptively reasonable.\item In some cases you may see a\_\- prepended to an argument name. It means \char`\"{}argument\char`\"{}. This was done when a global or module variable clashes with the argument name. It isn't required (local names take precedence) but it prevents ambiguity.\item Indent with spaces, and consistently within a file. Use F90 free-form syntax. Again, see gradient.f90.\item Try not to check in code with commented out sections.\end{itemize}


Avoid comments when clear code names will suffice. Comments should outline the intent of little blocks of code when that intent is not obvious. 